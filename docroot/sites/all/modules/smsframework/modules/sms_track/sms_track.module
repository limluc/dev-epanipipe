<?php
/**
 * @file
 * Message tracking feature module for Drupal SMS Framework.
 *
 * @package sms
 * @subpackage sms_track
 */



/**
 * Implements hook_help().
 *
 * @param $path
 *   URI string
 * @param $arg
 *  Page argument array
 *
 * @return
 *   HTML page content string
 */
function sms_track_help($path, $arg) {
  $output = '';
  switch ($path) {
    case "admin/help#sms_track":
      $output = '<p>' . t("<i>TO BE RE-WRITTEN</i> This module simply records all incoming and outgoing SMS messages from the SMS Framework. This can be used to enable an audit trail for your system, so that you can investigate any issues and keen an eye on what is flowing in and out.<br /><br /><strong>Outgoing: </strong>It is important to be aware of your outgoing SMS traffic because user spamming can be expensive for you, and may also expose you to legal issues. A small code error can cause this kind of problem.<br /><br /><strong>Incoming: </strong>The proper handling of inbound messages depends heavily on the quality of your software code. You may find that someone is sending malformed messages to your gateway receiver, which could expose a vulnerability and potentially release sensitive data.<br /><br />This module uses a database table to store messages, and implements Views for reporting.") . '</p>';
      break;
  }
  return $output;
}


/**
 * Implements hook_enable().
 */
function sms_track_enable() {
  if (variable_get('sms_track_archive_dir', SMS_DIR_NONE)) {
    watchdog('sms_track', 'SMS Tracking archive collector enabled');
  }
}


/**
 * Implements hook_disable().
 */
function sms_track_disable() {
  if (variable_get('sms_track_archive_dir', SMS_DIR_NONE)) {
    watchdog('sms_track', 'SMS Tracking archive collector DISABLED');
  }
}


/**
 * Implements hook_cron().
 */
function sms_track_cron() {
  // Ensure that we only run at most once per hour
  $last_run = variable_get('sms_track_archive_cron_last_run', 0);
  $time_an_hour_ago = REQUEST_TIME - 3600;
  if ($last_run <= $time_an_hour_ago) {
    // Purge the archive
    sms_track_archive_purge();
    variable_set('sms_track_archive_cron_last_run', REQUEST_TIME);
  }
}


/**
 * Implements hook_menu().
 *
 * @return
 *   Drupal menu items array
 */
function sms_track_menu() {
  $items = array();
//  $items['sms_parse'] = array(
//    'title' => 'SMS parse',
//    'type' => MENU_NORMAL_ITEM,
//
//    'page callback' => 'sms_track_insert',
//    //'page arguments' => array('sms_track_test'),
//    'access arguments' => array('administer smsframework'),
//    //'file' => 'sms_track.admin.inc',
//  );
  $items['admin/smsframework/sms_track'] = array(
    'title' => 'Message tracking',
    'description' => 'Options and view for the message archive.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sms_track_settings_form'),
    'access arguments' => array('administer smsframework'),
    'file' => 'sms_track.admin.inc',
  );
  $items['admin/smsframework/sms_track/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );
  $items['admin/smsframework/sms_track/view'] = array(
    'title' => 'View the archive',
    'file' => 'sms_track.admin.inc',
    'page callback' => 'sms_track_admin_view',
    'access arguments' => array('administer smsframework'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'file' => 'sms_track.admin.inc',
  );

  return $items;
}


/**
 * Implements hook_sms_send().
 */
function sms_track_sms_send($number, $message, &$options = array(), $gateway) {
  // Tracking
  // Place a tracking reference on a sent message if we need to
  if (!empty($options) && !array_key_exists('reference', $options)) {
    $options['reference'] = md5($number . $message);
  }
}

/**
 * Implements hook_sms_send_process().
 *
 * @param $op
 *   Operation string (pre process, process, post process)
 * @param $number
 *   MSISDN of recipient
 * @param $message
 *   SMS message body string
 * @param $options
 *   Additional options array including sender
 * @param $gateway
 *   Gateway array for the active gateway
 * @param $result
 *   Result array from the gateway response handler
 */
function sms_track_sms_send_process($op, $number, $message, $options, $gateway, $result) {
  if ($op == 'post process') {
    // Archiving
    $dir = 0; // outgoing
    $options['gateway_id'] = $gateway['identifier'];
    $options['result']  = $result;
    $result = sms_track_archive_write($dir, $number, $message, $options);
  }
}


/**
 * Implements hook_sms_incoming().
 *
 * @param $op
 *   SMS incoming operation string (pre process, process, post process)
 * @param $number
 *   MSISDN of sender
 * @param $message
 *   SMS message body string
 * @param $options
 *   Additional options array including receiver MSISDN
 */
function sms_track_sms_incoming($op, $number, $message, $options) {
  if ($op == 'pre process') {
    // Archiving
    $dir = 1; // incoming
    sms_track_archive_write($dir, $number, $message, $options);
  }
}


/**
 * Implements hook_sms_receipt().
 *
 * @param $op
 *   Operation string
 * @param $number
 *   MSISDN
 * @param $reference
 *   Reference code of the message
 * @param $message_status
 *   Message status code. See sms constants
 * @param $options
 *   Additional options array
 */
function sms_track_sms_receipt($op, $number, $reference, $status, $options) {
  if ($op == 'pre process') {
    // Tracking
    sms_track_update_message($reference, $status);
  }
}


/**
 * Write a record to the DB table
 *
 * @param $direction
 *   Direction integer of message (0=outgoing, 1=incoming)
 * @param $number
 *   MSISDN of remote
 * @param $message
 *   SMS message body string
 * @param $options
 *   Array of additional options
 * @return
 *   DB Query result
 */
function sms_track_archive_write($dir, $number, $message, $options = array()) {
  $archive_dir = variable_get('sms_track_archive_dir', SMS_DIR_NONE);

  if ($dir == 0) {
    // Outgoing
    if ($archive_dir == SMS_DIR_ALL || $archive_dir == SMS_DIR_OUT) {
      $reference = (array_key_exists('reference', $options)) ? $options['reference'] : NULL;

      // Status code may be provided by send result handler
      $status = (is_array($options['result'])) ? $options['result']['status_code'] : NULL;

      // Or render a status code from a simple true/false result
      if (! $status) {
        if ($options['result']) {
          $status = SMS_GW_OK;
        }
        else {
          $status = SMS_GW_ERR_OTHER;
        }
      }
    }
    else {
      return;
    }
  }
  elseif ($dir == 1) {
    // Incoming
    if ($archive_dir == SMS_DIR_ALL || $archive_dir == SMS_DIR_IN) {
      $reference = NULL;
      // Inbound message status is always the same
      $status = SMS_MSG_STATUS_OK;
    }
    else {
      return;
    }
  }

  $gw_number = (array_key_exists('gw_number', $options)) ? $options['gw_number'] : NULL;
  $created   = REQUEST_TIME;
  $options_z = serialize($options);

  // @TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query("INSERT INTO {sms_track} (reference, dir, number,
   gw_number, message, status, created, options) VALUES
   ('%s', %d, '%s', '%s', '%s', %d, %d, '%s')", $reference, $dir, $number, $gw_number, $message, $status, $created, $options_z) */

  $result = $id = db_insert('sms_track')
    ->fields(array(
      'reference' => $reference,
      'dir' => $dir,
      'number' => $number,
      'gw_number' => $gw_number,
      'message' => utf8_encode($message),
      'status' => $status,
      'created' => $created,
      'options' => $options_z,
    ))
    ->execute();

  if(module_exists('WSNobservations')){
    $MSG = sms_track_archive_parse_to_WSN($number,utf8_encode($message), $options_z);
    //twowaysms_send($number, $MSG, $options_z);
    echo $MSG;
    //sms_send($number, $MSG, $options_z);
  }
  if (! $result) {
    $to_from = ($dir == 0) ? 'To' : 'From';
    watchdog('sms_track', 'Failed to record message: ' . $to_from . ' ' . $number . ': ' . $message);
  }
}

/**
 * Update a message with a new status code
 *
 * @param $reference
 *   Message reference code
 * @param $status
 *   Message status code. See sms constants
 *
 * @todo Log record handling
 */
function sms_track_update_message($reference, $status) {
  $updated = REQUEST_TIME;

  watchdog('sms_track', $reference . ' ' . $status . ' ' . $updated);

  // @TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query('UPDATE {sms_track} SET status = %d, updated = %d WHERE reference = \'%s\'', $status, $updated, $reference) */
  $result = db_update('sms_track')
  ->fields(array(
    'status' => $status,
    'updated' => $updated,
  ))
  ->condition('reference', $reference)
  ->execute();

  if ($result) {
    watchdog('sms_track', 'Affected rows: ' . db_affected_rows($result));
  }
}


/**
 * Implements hook_views_api().
 *
 * @return
 *   Views API required information array
 */
function sms_track_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'sms_track') . '/views',
  );
}


/**
 * Purge all archived messages after a certain number of days
 *
 * @param $max_age_days
 *   Maximum age of tracked messages in days
 */
function sms_track_archive_purge($max_age_days = NULL) {
  // Get the configured max_age from the variable table if not given
  if (is_null($max_age_days)) {
    $max_age_days = variable_get('sms_track_archive_max_age_days', 0);
  }
  // Purge with no survivors
  if ($max_age_days > 0) {
    $max_age_secs = $max_age_days * 86400;
    $oldest = REQUEST_TIME - $max_age_secs;
    // @TODO Please review the conversion of this statement to the D7 database API syntax.
    /* db_query("DELETE FROM {sms_track} WHERE created < %d", $oldest) */
    $result = db_delete('sms_track')
    ->condition('created', $oldest, '<')
    ->execute();
  }
}


function sms_track_archive_parse_to_WSN($number, $message, $options = array()) {
//function sms_track_insert() {
//function sms_track_insert($message,$number) {
  //just for testing
  //$number = '447930272359';
  //$message = '£7J7J7J\'!7J7I8K\'!8I8I8J+!¤';
  $created = REQUEST_TIME;
  $str_len = 0;
  $dataStartBit = '£';
  $endbit = '¤';
  $specialStartBit = '¢';
  $rowdata = array();
  //if message is valid
  if(isset($message)){
    $query = db_select('WSNnodes', 'nod');
    //fields to be extracted
    $results = $query
      ->fields('nod', array('inputIdentifier','dataCompressionTech','timeInterval','occOrder','readNumOccurence','numSensorUnit','sensorDelimiter','dataDelimiter'))
      ->condition('inputIdentifier', $number)
      ->execute();
    
    //for check result //should be one only since inputIdentifier is unique number
     foreach ($results as $result) {
        $intervalSet = $result->timeInterval;
        $dataDelimiter = $result->dataDelimiter;
        $sensorDelimiter = $result->sensorDelimiter;
        $numSensorUnit = $result->numSensorUnit;
        $occOrder = $result->occOrder;
        //$numOccurence = $result->readNumOccurence; //only use if implementation has specific set of readings
        //for($i = 1; $i <= ($numOccurence); $i++){
        //for loop  for data
        if(substr($message,$str_len,2) == $specialStartBit){
              //water level loop - to be added
              $str_len=+2;
        }
        if(substr($message,$str_len,2) == $dataStartBit){
            //water level loop
            $str_len=+2;
            $dataSetAvail =  round(((strlen($message)-stristr($message,$endbit)-5)/$numSensorUnit));
            for($tloop = 1; $tloop <= $dataSetAvail; $tloop++){
                if($occOrder == 'ASC'){
                    $obsTime[$tloop] = $created-($intervalSet*($dataSetAvail-$tloop));
                     //echo $tloop.'_'.$dataSetAvail.'_'.$obsTime[$tloop].'____';
                }
                if($occOrder =='DESC'){
                    $obsTime[$tloop] = $created-($intervalSet*($tloop-1));
                }
            }
            //for($i = 1; $i <= ($numOccurence); $i++){
            for($i = 1; $i <= $dataSetAvail; $i++){
                while(substr($message,$str_len,1) == $dataDelimiter){
                    $str_len++;
                        if(substr($message,$str_len,1)== $dataDelimiter){
                            $str_len=$str_len+$numSensorUnit;
                        }
                }
                for($j = 1; $j <= ($numSensorUnit); $j++){
                      $query = db_select('WSNsensors', 'sen');
                      $query -> innerjoin('node', 'n','n.nid = sen.nid');
                      $query -> innerjoin('WSNnodes', 'nod', 'sen.nodes_nid = nod.nid');
                      $results = $query
                          ->fields('n', array('nid','vid','title'))
                          ->fields('nod', array('sites_title','sites_nid','inputIdentifier','dataCompressionTech','readNumOccurence','numSensorUnit','sensorDelimiter','dataDelimiter'))
                          ->fields('sen', array('nodes_title','nodes_nid','nid','vid','minOpRa','maxOpRa','polya0','polya1','polya2','orderBy','iCode'))
                          //->condition('n.type', 'WSNnodes')
                          ->condition('inputIdentifier', $number)
                          ->condition('orderBy', $j)
                          ->orderBy('nod.nid', 'ASC')
                          ->execute();
                      
                      foreach ($results as $result){
                            $errMSG = 'ER0';
                            $obsMSG = 'OK';
                            //skip if delimiter available
                          //echo substr($message,$str_len,1).$sensorDelimiter;
                          while(substr($message,$str_len,1) == $sensorDelimiter AND $sensorDelimiter != ''){
                                  $str_len++;
                          }
                          $value = substr($message,$str_len,1);
                          if(($result->dataCompressionTech) == 'CHARDEC'){
                              //data shifting
                              $value = ord($value)-31;
                              //data callibration and check
                              $value = ($result->polya0)+($result->polya1)*$value+($result->polya2)*$value*$value;
                              //if value unexpected
                              if($value<=($result->minOpRa) OR $value>=($result->maxOpRa)){
                                    $errMSG = 'ER2';
                                    $obsMSG = 'Error';
                              }
                          }
                          //debug save data to row  
//                          $rowdata[] = array(
//                            date('Y-m-d H:i', $obsTime[$i]),
//                            substr($message,$str_len,1),
//                            $result->vid,
//                            $value,
//                            $errMSG,
//                            $obsMSG,
//                            $str_len,
//                            );
                          $node = new stdclass();
                            $node->type = 'WSNobservations';
                            $node->title = $result->nid.$obsTime[$i];
                            $node->sites_nid = $result->sites_nid;
                            $node->sites_title = $result->sites_title;
                            $node->nodes_nid = $result->nodes_nid;
                            $node->nodes_title = $result->nodes_title;
                            $node->sensors_nid = $result->nid;
                            $node->sensors_title = $result->title;
                            $node->value  = $value;
                            $node->datetime  = date('Y-m-d H:i',$obsTime[$i]);
                            $node->observationError = $errMSG;
                            $node->observationCategory = $obsMSG;
                         node_save($node);
                    } //forereach
                   $str_len++;
                }//next sensor for loop 
              }//next data for loop
            }//valid data if statement  
        } //data set equal inputIdentifier
    }//if message is valid
    //$header = array(t('Date Time'),t('Sensor'),t('Value'));
    //return theme('table', array('header' => $header, 'rows' =>$rowdata));  
    return 'OK';
}   